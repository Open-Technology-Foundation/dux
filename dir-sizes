#!/usr/bin/env bash
# dux - Quick directory size overview (sorted smallest to largest)
set -euo pipefail
shopt -s inherit_errexit shift_verbose extglob nullglob

# Lock down PATH for security
readonly PATH="/usr/local/bin:/usr/bin:/bin"
export PATH

declare -r VERSION='1.4.0'
declare -r SCRIPT_NAME=${0##*/} # Script basename

# Global for trap cleanup
declare -- DIRSIZES_TMPFILE=''

# Runtime flags
declare -i FOLLOW_SYMLINKS=0 VERBOSE=1

# Core message function
_msg() {
  local -- prefix="$SCRIPT_NAME:" msg
  for msg in "$@"; do printf '%s %s\n' "$prefix" "$msg"; done
}
# Error message to stderr
error() { >&2 _msg "$@"; }
# Exit with error
die() { (($#>1)) && error "${@:2}"; exit "${1:-0}"; }

# --------------------------------------------------------------------------------
# Usage documentation
# --------------------------------------------------------------------------------
show_help() {
  cat <<EOT
$SCRIPT_NAME $VERSION - Quick directory size overview

Find out where your disk space is going. Shows the size of each subdirectory,
sorted smallest to largest (largest at bottom for easy viewing).

USAGE
  $SCRIPT_NAME [OPTIONS] [DIRECTORY]
  $SCRIPT_NAME -h | -V

OPTIONS
  -L             Follow symlinks
  -q, --quiet    Suppress permission errors
  -h, --help     Show this help
  -V, --version  Show version

EXAMPLES
  $SCRIPT_NAME              # Current directory
  $SCRIPT_NAME /var         # Check /var subdirectories
  $SCRIPT_NAME ~ | tail -5  # 5 largest in home directory
  sudo $SCRIPT_NAME /       # Full system (needs root)

OUTPUT
  <size>    <path>

  Sizes use IEC units (KiB, MiB, GiB). Tab-separated for easy parsing.
  Permission errors go to stderr; accessible content is still shown.

EXIT CODES
  0   Success
  1   Error (invalid directory, read failure)
  2   Too many arguments
  22  Invalid option

More info: https://github.com/Open-Technology-Foundation/dux
EOT
}

# --------------------------------------------------------------------------------
# Cleanup function for trap
# --------------------------------------------------------------------------------
cleanup() {
  if [[ -n "${DIRSIZES_TMPFILE:-}" ]] && [[ -f "$DIRSIZES_TMPFILE" ]]; then
    rm -f "$DIRSIZES_TMPFILE"
  fi
  exit "${1:-0}"
}

# --------------------------------------------------------------------------------
# Main function
# --------------------------------------------------------------------------------
main() {
  local -a dirs=()
  local -- dir='' hr_size=''
  local -i size=0

  # Parse arguments
  while (($#)); do
    case $1 in
      -h|--help)    show_help; exit 0 ;;
      -V|--version) echo "$SCRIPT_NAME $VERSION"; exit 0 ;;
      -L)           FOLLOW_SYMLINKS=1 ;;
      -q|--quiet)   VERBOSE=0 ;;
      -[hVLq]*) #shellcheck disable=SC2046 #split up single options
                    set -- '' $(printf -- '-%c ' $(grep -o . <<<"${1:1}")) "${@:2}"
                    ;;
      -*)           die 22 "Invalid option ${1@Q}" ;;
      *)            [[ -n "$dir" ]] && die 2 "Too many arguments ${1@Q}"
                    dir="$1"
                    ;;
    esac
    shift
  done

  # Default to current directory if no directory specified
  : "${dir:=./}"

  # Validate directory exists
  [[ -d "$dir" ]] || die 1 "Not a directory ${dir@Q}"

  # Set up temp file (use global for trap access)
  DIRSIZES_TMPFILE=$(mktemp) || die 1 'Failed to create temporary file'

  # Set trap for cleanup
  trap 'cleanup $?' SIGINT SIGTERM EXIT

  # Find all directories at depth 1
  local -a find_opts=()
  ((FOLLOW_SYMLINKS)) && find_opts+=(-L)
  readarray -t dirs < <(find "${find_opts[@]}" "$dir" -maxdepth 1 -type d 2>/dev/null || true)

  # Check if we found any directories
  ((${#dirs[@]})) || die 1 "No directories found in ${dir@Q}"

  # First pass: collect directory sizes directly using du
  # Temp file already created by mktemp, just ensure it's empty
  : > "$DIRSIZES_TMPFILE"

  local -- current_dir
  for current_dir in "${dirs[@]}"; do
    # Get the raw size in bytes using du
    # du may return exit code 1 on permission errors but still outputs the size it could calculate
    if ((VERBOSE)); then
      size=$(du -sb "$current_dir" 2>&2 | cut -f1 || echo '')
    else
      size=$(du -sb "$current_dir" 2>/dev/null | cut -f1 || echo '')
    fi

    # Check if we got a valid size
    if [[ -z "$size" ]] || [[ ! "$size" =~ ^[0-9]+$ ]]; then
      die 1 "Failed to calculate size for ${current_dir@Q}"
    fi

    # Write to temporary file with proper format
    printf "%15d 0 %s\n" "$size" "$current_dir" >> "$DIRSIZES_TMPFILE"
  done

  # Sort by size
  sort -n "$DIRSIZES_TMPFILE" > "$DIRSIZES_TMPFILE".sorted
  mv "$DIRSIZES_TMPFILE".sorted "$DIRSIZES_TMPFILE"

  # Second pass: display with human-readable sizes while preserving order
  local -- output_dir
  while read -r size _ output_dir; do
    hr_size=$(numfmt --to=iec --suffix=B --format="%.1f" "$size")
    printf "%-10s\t%s\n" "$hr_size" "$output_dir"
  done < "$DIRSIZES_TMPFILE"

  # Clean up (trap will handle this, but being explicit)
  rm -f "$DIRSIZES_TMPFILE"

  return 0
}

main "$@"
#fin
