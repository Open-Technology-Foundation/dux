#!/bin/bash
# Display directory sizes in sorted human-readable format
set -euo pipefail
# Critical shopt settings for safety
shopt -s inherit_errexit shift_verbose extglob nullglob

# Lock down PATH for security
readonly PATH="/usr/local/bin:/usr/bin:/bin"
export PATH

VERSION='1.2.0'
SCRIPT_PATH=$(readlink -en -- "$0")  # Full path to script
SCRIPT_NAME=${SCRIPT_PATH##*/}       # Script basename
readonly -- VERSION SCRIPT_PATH SCRIPT_NAME

# Global for trap cleanup
declare -- DIRSIZES_TMPFILE=''

# Core message function
_msg() {
  local -- prefix="$SCRIPT_NAME:" msg
  for msg in "$@"; do printf '%s %s\n' "$prefix" "$msg"; done
}
# Error message to stderr
error() { >&2 _msg "$@"; }
# Exit with error
die() { (($# > 1)) && error "${@:2}"; exit "${1:-0}"; }

# --------------------------------------------------------------------------------
# Usage documentation
# --------------------------------------------------------------------------------
usage() {
  cat <<EOT
$SCRIPT_NAME $VERSION - Display directory sizes in sorted human-readable format

DESCRIPTION
  Calculates and displays the total size of each subdirectory in the specified
  directory, sorted from smallest to largest. Provides a quick overview of disk
  usage distribution within a directory hierarchy.

USAGE
  $SCRIPT_NAME [OPTIONS] [DIRECTORY]

OPTIONS
  -h, --help     Display this help message and exit
  -V, --version  Display version information and exit

ARGUMENTS
  DIRECTORY      Directory to analyze (defaults to current directory)
                 Must be a valid, accessible directory path

EXAMPLES
  $SCRIPT_NAME                 # Analyze current directory
  $SCRIPT_NAME /var            # Analyze /var subdirectories
  $SCRIPT_NAME ~/Documents     # Analyze home Documents folder

OUTPUT FORMAT
  <size>  <path>

  Where:
  - <size> is human-readable with IEC units (B, KiB, MiB, GiB, TiB)
  - <path> is the absolute or relative directory path
  - Output is tab-separated for easy parsing
  - Sorted by size, smallest to largest

FEATURES
  - Recursive size calculation (includes all nested content)
  - Human-readable output with automatic unit selection
  - Handles permission errors gracefully (partial results shown)
  - Secure temporary file handling with automatic cleanup
  - Signal handling for clean interruption (Ctrl+C safe)

NOTES
  - Uses 'du -sb' for actual disk usage calculation
  - Permission errors are reported to stderr but don't halt execution
  - Empty directories show as 0.0B
  - Temporary files are created securely with mktemp

EXIT CODES
  0   Success
  1   General error (invalid directory, du failure, temp file error)
  22  Invalid command-line option
EOT
  exit "${1:-0}"
}

# --------------------------------------------------------------------------------
# Cleanup function for trap
# --------------------------------------------------------------------------------
cleanup() {
  local -i exitcode=${1:-0}
  [[ -n "${DIRSIZES_TMPFILE:-}" ]] && [[ -f "$DIRSIZES_TMPFILE" ]] && rm -f "$DIRSIZES_TMPFILE"
  exit "$exitcode"
}

# --------------------------------------------------------------------------------
# Main function
# --------------------------------------------------------------------------------
main() {
  local -a dirs=()
  local -- dir='' hr_size=''
  local -i size=0

  # Parse arguments
  while (($#)); do
    case "$1" in
      -h|--help)    usage 0 ;;
      -V|--version) echo "$SCRIPT_NAME $VERSION"; exit 0 ;;
      -[hV]*) #shellcheck disable=SC2046 #split up single options
                    set -- '' $(printf -- "-%c " $(grep -o . <<<"${1:1}")) "${@:2}"
                    ;;
      -*)           die 22 "Invalid option '$1'" ;;
      *)            [[ -n "$dir" ]] && die 1 'Too many arguments'
                    dir="$1"
                    ;;
    esac
    shift
  done

  # Default to current directory if no directory specified
  : "${dir:=./}"

  # Validate directory exists
  [[ -d "$dir" ]] || die 1 "Not a directory: '$dir'"

  # Set up temp file (use global for trap access)
  DIRSIZES_TMPFILE=$(mktemp) || die 1 "Failed to create temporary file"

  # Set trap for cleanup
  trap 'cleanup $?' SIGINT SIGTERM EXIT

  # Find all directories at depth 1
  readarray -t dirs < <(find "$dir" -maxdepth 1 -type d 2>/dev/null || true)

  # Check if we found any directories
  ((${#dirs[@]})) || die 1 "No directories found in '$dir'"

  # First pass: collect directory sizes directly using du
  # Temp file already created by mktemp, just ensure it's empty
  : > "$DIRSIZES_TMPFILE"

  local -- current_dir
  for current_dir in "${dirs[@]}"; do
    # Get the raw size in bytes using du
    # du may return exit code 1 on permission errors but still outputs the size it could calculate
    # Send errors to stderr where they belong, capture only the size
    size=$(du -sb "$current_dir" 2>&2 | cut -f1 || echo '')

    # Check if we got a valid size
    if [[ -z "$size" ]] || [[ ! "$size" =~ ^[0-9]+$ ]]; then
      die 1 "Failed to calculate size for '$current_dir'"
    fi

    # Write to temporary file with proper format
    printf "%15d 0 %s\n" "$size" "$current_dir" >> "$DIRSIZES_TMPFILE"
  done

  # Sort by size
  sort -n "$DIRSIZES_TMPFILE" > "${DIRSIZES_TMPFILE}.sorted"
  mv "${DIRSIZES_TMPFILE}.sorted" "$DIRSIZES_TMPFILE"

  # Second pass: display with human-readable sizes while preserving order
  local -- output_dir dummy
  # shellcheck disable=SC2034  # dummy is used to consume middle field
  while read -r size dummy output_dir; do
    hr_size=$(numfmt --to=iec --suffix=B --format="%.1f" "$size")
    printf "%-10s\t%s\n" "$hr_size" "$output_dir"
  done < "$DIRSIZES_TMPFILE"

  # Clean up (trap will handle this, but being explicit)
  rm -f "$DIRSIZES_TMPFILE"

  return 0
}

main "$@"
#fin
